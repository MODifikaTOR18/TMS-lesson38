@Library(['build', 'general']) _

pipeline {
    agent any

    options {
        buildDiscarder(logRotator(numToKeepStr: '5'))
        disableConcurrentBuilds()
        timestamps()
        ansiColor('xtrem')
    }

    environment {
        SERVICES_FILE = 'simple-java-project/apps/services.json'
        GIT_REPO_OWNER = 'MODifikaTOR18'
        GIT_REPO_NAME = 'TMS-lesson37'
        DOCKER_REGISTRY = "ghcr.io/${GIT_REPO_OWNER.toLowerCase()}"
    }

    stages {
        stage('Prepare') {
            steps {
                script {
                    PR_ID = prID.prID(env.BRANCH_NAME)
                    apps = readJSON file: SERVICES_FILE
                    log.info ("Branch: ${env.BRANCH_NAME}")
                    log.info ("Pull request ID: ${PR_ID}")

                    TAG_STACK = sh(returnStdout: true, script: "git tag --sort version:refname | tail -1").trim()
                    
                    TAG = (TAG_STACK.isEmpty()) ? 'latest' : TAG_STACK
                    log.info ("Current tag for build is: ${TAG}")
                    PR_DIFF=[]
                    BUILD_APPS=[:]
                    
                    PR_DIFF=sh(script: 'git show --pretty=format: --name-only', returnStdout: true).trim()
                    log.info ("Pull request diffs:\n${PR_DIFF}")
                    if (PR_ID.isEmpty()) {
                        def response = httpRequest url: "https://api.github.com/repos/${GIT_REPO_OWNER}/${GIT_REPO_NAME}/pulls/${PR_ID}/files",
                                                    customHeaders: [[name: 'Accept', value: 'application/vnd.github+json'],[name: 'X-GitHub-Api-Version', value: '2022-11-28']],
                                                    authentication: 'github-http'


                        log.info("Request status Github API: "+response.status)
                        PR_DIFF_DATA = readJSON text: response.content
                        PR_DIFF_DATA.each { item ->
                            PR_DIFF.add(item.filename)
                        }
                        log.info ("PR diff: ${PR_DIFF}")
                        apps.each { app, path ->
                            if (isChanged.isChanged(PR_DIFF, path)) {
                                BUILD_APPS.put(app, path)
                            }
                        }
                    } else {
                        BUILD_APPS = apps
                    }
                    
                    log.info("Build apps: ${BUILD_APPS}")
                    Integer PARALLEL_EXECUTE_COUNT = 3
                    buildStages = stagePrepare.stagePrepare('build', BUILD_APPS, PARALLEL_EXECUTE_COUNT)
                    builtApps = [:]
                }
            }
        }

        stage ('Parallel build') {
            steps {
                script {
                    buildStages.each { stage ->
                        parallel stage
                    }
                }
            }
        }

        stage ('Parallel create image') {
            when { expression { BRANCH_NAME == 'master' || BRANCH_NAME ==~ "PR-"+/\d+/ } }
            steps {
                script {
                    Integer PARALLEL_EXECUTE_COUNT = 3
                    createImageStages = stagePrepare.stagePrepare('image', builtApps, PARALLEL_EXECUTE_COUNT)
                    createImageStages.each { stage ->
                        parallel stage
                    }
                }
            }
        }

        stage ('Push image') {
            when { expression { BRANCH_NAME == 'master' || BRANCH_NAME ==~ "PR-"+/\d+/ } }
            steps {
                script {
                    withCredentials([usernamePassword(credentialsId: 'GitHub_ID', passwordVariable: 'pass', usernameVariable: 'user')]) {
                        sh "echo ${pass} | docker login ${DOCKER_REGISTRY} -u ${user} --password-stdin"
                    }
                    builtApps.each { app, path ->
                        sh "docker push ${DOCKER_REGISTRY}/${app}:${TAG}"
                    }
                }
            }
        }

    }
    post {
        always {
            cleanWs()
        }
    }
}